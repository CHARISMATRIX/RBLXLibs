local a;do local b={}local c={}local d={}local e={}local f={}local g={}local h=8;local function i(j)if not j then error("assertion failed!")end end;function b:make_getS(k)local l=k;return function()if not l then return nil end;local m=l;l=nil;return m end end;function b:make_getF(n)local o=512;local p=1;return function()local k=n:sub(p,p+o-1)p=math.min(#n+1,p+o)return k end end;function b:init(q,m)if not q then return end;local r={}r.reader=q;r.data=m or""r.name=name;if not m or m==""then r.n=0 else r.n=#m end;r.p=0;return r end;function b:fill(r)local k=r.reader()r.data=k;if not k or k==""then return"EOZ"end;r.n,r.p=#k-1,1;return string.sub(k,1,1)end;function b:zgetc(r)local s,t=r.n,r.p+1;if s>0 then r.n,r.p=s-1,t;return string.sub(r.data,t,t)else return self:fill(r)end end;d.RESERVED="\nTK_AND and\nTK_BREAK break\nTK_DO do\nTK_ELSE else\nTK_ELSEIF elseif\nTK_END end\nTK_FALSE false\nTK_FOR for\nTK_FUNCTION function\nTK_IF if\nTK_IN in\nTK_LOCAL local\nTK_NIL nil\nTK_NOT not\nTK_OR or\nTK_REPEAT repeat\nTK_RETURN return\nTK_THEN then\nTK_TRUE true\nTK_UNTIL until\nTK_WHILE while\nTK_CONCAT ..\nTK_DOTS ...\nTK_EQ ==\nTK_GE >=\nTK_LE <=\nTK_NE ~=\nTK_NAME <name>\nTK_NUMBER <number>\nTK_STRING <string>\nTK_EOS <eof>"d.MAXSRC=80;d.MAX_INT=2147483645;d.LUA_QS="'%s'"d.LUA_COMPAT_LSTR=1;function d:init()local u,v={},{}for w in string.gmatch(self.RESERVED,"[^\n]+")do local y,y,z,A=string.find(w,"(%S+)%s+(%S+)")u[z]=A;v[A]=z end;self.tokens=u;self.enums=v end;function d:chunkid(n,B)local C;local D=string.sub(n,1,1)if D=="="then C=string.sub(n,2,B)else if D=="@"then n=string.sub(n,2)B=B-#" '...' "local E=#n;C=""if E>B then n=string.sub(n,1+E-B)C=C.."..."end;C=C..n else local F=string.find(n,"[\n\r]")F=F and F-1 or#n;B=B-#" [string \"...\"] "if F>B then F=B end;C="[string \""if F<#n then C=C..string.sub(n,1,F).."..."else C=C..n end;C=C.."\"]"end end;return C end;function d:token2str(G,H)if string.sub(H,1,3)~="TK_"then if string.find(H,"%c")then return string.format("char(%d)",string.byte(H))end;return H else return self.tokens[H]end end;function d:lexerror(G,I,H)local function J(G,H)if H=="TK_NAME"or H=="TK_STRING"or H=="TK_NUMBER"then return G.buff else return self:token2str(G,H)end end;local k=self:chunkid(G.source,self.MAXSRC)local I=string.format("%s:%d: %s",k,G.linenumber,I)if H then I=string.format("%s near "..self.LUA_QS,I,J(G,H))end;error(I)end;function d:syntaxerror(G,I)self:lexerror(G,I,G.t.token)end;function d:currIsNewline(G)return G.current=="\n"or G.current=="\r"end;function d:inclinenumber(G)local K=G.current;self:nextc(G)if self:currIsNewline(G)and G.current~=K then self:nextc(G)end;G.linenumber=G.linenumber+1;if G.linenumber>=self.MAX_INT then self:syntaxerror(G,"chunk has too many lines")end end;function d:setinput(L,G,r,n)if not G then G={}end;if not G.lookahead then G.lookahead={}end;if not G.t then G.t={}end;G.decpoint="."G.L=L;G.lookahead.token="TK_EOS"G.z=r;G.fs=nil;G.linenumber=1;G.lastline=1;G.source=n;self:nextc(G)end;function d:check_next(G,M)if not string.find(M,G.current,1,1)then return false end;self:save_and_next(G)return true end;function d:next(G)G.lastline=G.linenumber;if G.lookahead.token~="TK_EOS"then G.t.seminfo=G.lookahead.seminfo;G.t.token=G.lookahead.token;G.lookahead.token="TK_EOS"else G.t.token=self:llex(G,G.t)end end;function d:lookahead(G)G.lookahead.token=self:llex(G,G.lookahead)end;function d:nextc(G)local N=b:zgetc(G.z)G.current=N;return N end;function d:save(G,N)local k=G.buff;G.buff=k..N end;function d:save_and_next(G)self:save(G,G.current)return self:nextc(G)end;function d:str2d(O)local P=tonumber(O)if P then return P end;if string.lower(string.sub(O,1,2))=="0x"then P=tonumber(O,16)if P then return P end end;return nil end;function d:buffreplace(G,Q,R)local P,k="",G.buff;for t=1,#k do local N=string.sub(k,t,t)if N==Q then N=R end;P=P..N end;G.buff=P end;function d:trydecpoint(G,S)local K=G.decpoint;self:buffreplace(G,K,G.decpoint)local T=self:str2d(G.buff)S.seminfo=T;if not T then self:buffreplace(G,G.decpoint,".")self:lexerror(G,"malformed number","TK_NUMBER")end end;function d:read_numeral(G,S)repeat self:save_and_next(G)until string.find(G.current,"%D")and G.current~="."if self:check_next(G,"Ee")then self:check_next(G,"+-")end;while string.find(G.current,"^%w$")or G.current=="_"do self:save_and_next(G)end;self:buffreplace(G,".",G.decpoint)local T=self:str2d(G.buff)S.seminfo=T;if not T then self:trydecpoint(G,S)end end;function d:skip_sep(G)local U=0;local O=G.current;self:save_and_next(G)while G.current=="="do self:save_and_next(G)U=U+1 end;return G.current==O and U or-U-1 end;function d:read_long_string(G,S,V)local W=0;self:save_and_next(G)if self:currIsNewline(G)then self:inclinenumber(G)end;while true do local N=G.current;if N=="EOZ"then self:lexerror(G,S and"unfinished long string"or"unfinished long comment","TK_EOS")elseif N=="["then if self.LUA_COMPAT_LSTR then if self:skip_sep(G)==V then self:save_and_next(G)W=W+1;if self.LUA_COMPAT_LSTR==1 then if V==0 then self:lexerror(G,"nesting of [[...]] is deprecated","[")end end end end elseif N=="]"then if self:skip_sep(G)==V then self:save_and_next(G)if self.LUA_COMPAT_LSTR and self.LUA_COMPAT_LSTR==2 then W=W-1;if V==0 and W>=0 then break end end;break end elseif self:currIsNewline(G)then self:save(G,"\n")self:inclinenumber(G)if not S then G.buff=""end else if S then self:save_and_next(G)else self:nextc(G)end end end;if S then local t=3+V;S.seminfo=string.sub(G.buff,t,-t)end end;function d:read_string(G,X,S)self:save_and_next(G)while G.current~=X do local N=G.current;if N=="EOZ"then self:lexerror(G,"unfinished string","TK_EOS")elseif self:currIsNewline(G)then self:lexerror(G,"unfinished string","TK_STRING")elseif N=="\\"then N=self:nextc(G)if self:currIsNewline(G)then self:save(G,"\n")self:inclinenumber(G)elseif N~="EOZ"then local Y=string.find("abfnrtv",N,1,1)if Y then self:save(G,string.sub("\a\b\f\n\r\t\v",Y,Y))self:nextc(G)elseif not string.find(N,"%d")then self:save_and_next(G)else N,Y=0,0;repeat N=10*N+G.current;self:nextc(G)Y=Y+1 until Y>=3 or not string.find(G.current,"%d")if N>255 then self:lexerror(G,"escape sequence too large","TK_STRING")end;self:save(G,string.char(N))end end else self:save_and_next(G)end end;self:save_and_next(G)S.seminfo=string.sub(G.buff,2,-2)end;function d:llex(G,S)G.buff=""while true do local N=G.current;if self:currIsNewline(G)then self:inclinenumber(G)elseif N=="-"then N=self:nextc(G)if N~="-"then return"-"end;local V=-1;if self:nextc(G)=='['then V=self:skip_sep(G)G.buff=""end;if V>=0 then self:read_long_string(G,nil,V)G.buff=""else while not self:currIsNewline(G)and G.current~="EOZ"do self:nextc(G)end end elseif N=="["then local V=self:skip_sep(G)if V>=0 then self:read_long_string(G,S,V)return"TK_STRING"elseif V==-1 then return"["else self:lexerror(G,"invalid long string delimiter","TK_STRING")end elseif N=="="then N=self:nextc(G)if N~="="then return"="else self:nextc(G)return"TK_EQ"end elseif N=="<"then N=self:nextc(G)if N~="="then return"<"else self:nextc(G)return"TK_LE"end elseif N==">"then N=self:nextc(G)if N~="="then return">"else self:nextc(G)return"TK_GE"end elseif N=="~"then N=self:nextc(G)if N~="="then return"~"else self:nextc(G)return"TK_NE"end elseif N=="\""or N=="'"then self:read_string(G,N,S)return"TK_STRING"elseif N=="."then N=self:save_and_next(G)if self:check_next(G,".")then if self:check_next(G,".")then return"TK_DOTS"else return"TK_CONCAT"end elseif not string.find(N,"%d")then return"."else self:read_numeral(G,S)return"TK_NUMBER"end elseif N=="EOZ"then return"TK_EOS"else if string.find(N,"%s")then self:nextc(G)elseif string.find(N,"%d")then self:read_numeral(G,S)return"TK_NUMBER"elseif string.find(N,"[_%a]")then repeat N=self:save_and_next(G)until N=="EOZ"or not string.find(N,"[_%w]")local Z=G.buff;local z=self.enums[Z]if z then return z end;S.seminfo=Z;return"TK_NAME"else self:nextc(G)return N end end end end;e.OpMode={iABC=0,iABx=1,iAsBx=2}e.SIZE_C=9;e.SIZE_B=9;e.SIZE_Bx=e.SIZE_C+e.SIZE_B;e.SIZE_A=8;e.SIZE_OP=6;e.POS_OP=0;e.POS_A=e.POS_OP+e.SIZE_OP;e.POS_C=e.POS_A+e.SIZE_A;e.POS_B=e.POS_C+e.SIZE_C;e.POS_Bx=e.POS_C;e.MAXARG_Bx=math.ldexp(1,e.SIZE_Bx)-1;e.MAXARG_sBx=math.floor(e.MAXARG_Bx/2)e.MAXARG_A=math.ldexp(1,e.SIZE_A)-1;e.MAXARG_B=math.ldexp(1,e.SIZE_B)-1;e.MAXARG_C=math.ldexp(1,e.SIZE_C)-1;function e:GET_OPCODE(Y)return self.ROpCode[Y.OP]end;function e:SET_OPCODE(Y,_)Y.OP=self.OpCode[_]end;function e:GETARG_A(Y)return Y.A end;function e:SETARG_A(Y,a0)Y.A=a0 end;function e:GETARG_B(Y)return Y.B end;function e:SETARG_B(Y,l)Y.B=l end;function e:GETARG_C(Y)return Y.C end;function e:SETARG_C(Y,l)Y.C=l end;function e:GETARG_Bx(Y)return Y.Bx end;function e:SETARG_Bx(Y,l)Y.Bx=l end;function e:GETARG_sBx(Y)return Y.Bx-self.MAXARG_sBx end;function e:SETARG_sBx(Y,l)Y.Bx=l+self.MAXARG_sBx end;function e:CREATE_ABC(_,a1,l,N)return{OP=self.OpCode[_],A=a1,B=l,C=N}end;function e:CREATE_ABx(_,a1,a2)return{OP=self.OpCode[_],A=a1,Bx=a2}end;function e:CREATE_Inst(N)local _=N%64;N=(N-_)/64;local a1=N%256;N=(N-a1)/256;return self:CREATE_ABx(_,a1,N)end;function e:Instruction(Y)if Y.Bx then Y.C=Y.Bx%512;Y.B=(Y.Bx-Y.C)/512 end;local a3=Y.A*64+Y.OP;local a4=a3%256;a3=Y.C*64+(a3-a4)/256;local a5=a3%256;a3=Y.B*128+(a3-a5)/256;local a6=a3%256;local a7=(a3-a6)/256;return string.char(a4,a5,a6,a7)end;function e:DecodeInst(x)local a8=string.byte;local Y={}local a3=a8(x,1)local a9=a3%64;Y.OP=a9;a3=a8(x,2)*4+(a3-a9)/64;local a1=a3%256;Y.A=a1;a3=a8(x,3)*4+(a3-a1)/256;local N=a3%512;Y.C=N;Y.B=a8(x,4)*2+(a3-N)/512;local aa=self.OpMode[tonumber(string.sub(self.opmodes[a9+1],7,7))]if aa~="iABC"then Y.Bx=Y.B*512+Y.C end;return Y end;e.BITRK=math.ldexp(1,e.SIZE_B-1)function e:ISK(x)return x>=self.BITRK end;function e:INDEXK(ab)return x-self.BITRK end;e.MAXINDEXRK=e.BITRK-1;function e:RKASK(x)return x+self.BITRK end;e.NO_REG=e.MAXARG_A;e.opnames={}e.OpCode={}e.ROpCode={}local Y=0;for w in string.gmatch("\nMOVE LOADK LOADBOOL LOADNIL GETUPVAL\nGETGLOBAL GETTABLE SETGLOBAL SETUPVAL SETTABLE\nNEWTABLE SELF ADD SUB MUL\nDIV MOD POW UNM NOT\nLEN CONCAT JMP EQ LT\nLE TEST TESTSET CALL TAILCALL\nRETURN FORLOOP FORPREP TFORLOOP SETLIST\nCLOSE CLOSURE VARARG\n","%S+")do local s="OP_"..w;e.opnames[Y]=w;e.OpCode[s]=Y;e.ROpCode[Y]=s;Y=Y+1 end;e.NUM_OPCODES=Y;e.OpArgMask={OpArgN=0,OpArgU=1,OpArgR=2,OpArgK=3}function e:getOpMode(ac)return self.opmodes[self.OpCode[ac]]%4 end;function e:getBMode(ac)return math.floor(self.opmodes[self.OpCode[ac]]/16)%4 end;function e:getCMode(ac)return math.floor(self.opmodes[self.OpCode[ac]]/4)%4 end;function e:testAMode(ac)return math.floor(self.opmodes[self.OpCode[ac]]/64)%2 end;function e:testTMode(ac)return math.floor(self.opmodes[self.OpCode[ac]]/128)end;e.LFIELDS_PER_FLUSH=50;local function aa(ad,a1,l,N,ac)local e=e;return ad*128+a1*64+e.OpArgMask[l]*16+e.OpArgMask[N]*4+e.OpMode[ac]end;e.opmodes={aa(0,1,"OpArgK","OpArgN","iABx"),aa(0,1,"OpArgU","OpArgU","iABC"),aa(0,1,"OpArgR","OpArgN","iABC"),aa(0,1,"OpArgU","OpArgN","iABC"),aa(0,1,"OpArgK","OpArgN","iABx"),aa(0,1,"OpArgR","OpArgK","iABC"),aa(0,0,"OpArgK","OpArgN","iABx"),aa(0,0,"OpArgU","OpArgN","iABC"),aa(0,0,"OpArgK","OpArgK","iABC"),aa(0,1,"OpArgU","OpArgU","iABC"),aa(0,1,"OpArgR","OpArgK","iABC"),aa(0,1,"OpArgK","OpArgK","iABC"),aa(0,1,"OpArgK","OpArgK","iABC"),aa(0,1,"OpArgK","OpArgK","iABC"),aa(0,1,"OpArgK","OpArgK","iABC"),aa(0,1,"OpArgK","OpArgK","iABC"),aa(0,1,"OpArgK","OpArgK","iABC"),aa(0,1,"OpArgR","OpArgN","iABC"),aa(0,1,"OpArgR","OpArgN","iABC"),aa(0,1,"OpArgR","OpArgN","iABC"),aa(0,1,"OpArgR","OpArgR","iABC"),aa(0,0,"OpArgR","OpArgN","iAsBx"),aa(1,0,"OpArgK","OpArgK","iABC"),aa(1,0,"OpArgK","OpArgK","iABC"),aa(1,0,"OpArgK","OpArgK","iABC"),aa(1,1,"OpArgR","OpArgU","iABC"),aa(1,1,"OpArgR","OpArgU","iABC"),aa(0,1,"OpArgU","OpArgU","iABC"),aa(0,1,"OpArgU","OpArgU","iABC"),aa(0,0,"OpArgU","OpArgN","iABC"),aa(0,1,"OpArgR","OpArgN","iAsBx"),aa(0,1,"OpArgR","OpArgN","iAsBx"),aa(1,0,"OpArgN","OpArgU","iABC"),aa(0,0,"OpArgU","OpArgU","iABC"),aa(0,0,"OpArgN","OpArgN","iABC"),aa(0,1,"OpArgU","OpArgN","iABx"),aa(0,1,"OpArgU","OpArgN","iABC")}e.opmodes[0]=aa(0,1,"OpArgR","OpArgN","iABC")f.LUA_SIGNATURE="\27Lua"f.LUA_TNUMBER=3;f.LUA_TSTRING=4;f.LUA_TNIL=0;f.LUA_TBOOLEAN=1;f.LUA_TNONE=-1;f.LUAC_VERSION=0x51;f.LUAC_FORMAT=0;f.LUAC_HEADERSIZE=12;function f:make_setS()local k={}k.data=""local ae=function(O,k)if not O then return 0 end;k.data=k.data..O;return 0 end;return ae,k end;function f:make_setF(af)local k={}k.h=io.open(af,"wb")if not k.h then return nil end;local ae=function(O,k)if not k.h then return 0 end;if not O then if k.h:close()then return 0 end else if k.h:write(O)then return 0 end end;return 1 end;return ae,k end;function f:ttype(_)local ag=type(_.value)if ag=="number"then return self.LUA_TNUMBER elseif ag=="string"then return self.LUA_TSTRING elseif ag=="nil"then return self.LUA_TNIL elseif ag=="boolean"then return self.LUA_TBOOLEAN else return self.LUA_TNONE end end;function f:from_double(x)local function ah(w)local N=w%256;return(w-N)/256,string.char(N)end;local ai=0;if x<0 then ai=1;x=-x end;local aj,ak=math.frexp(x)if x==0 then aj,ak=0,0 elseif x==1/0 then aj,ak=0,2047 else aj=(aj*2-1)*math.ldexp(0.5,53)ak=ak+1022 end;local w,a8=""x=math.floor(aj)for Y=1,6 do x,a8=ah(x)w=w..a8 end;x,a8=ah(ak*16+x)w=w..a8;x,a8=ah(ai*128+x)w=w..a8;return w end;function f:from_int(x)local w=""x=math.floor(x)if x<0 then x=4294967296+x end;for Y=1,4 do local N=x%256;w=w..string.char(N)x=math.floor(x/256)end;return w end;function f:DumpBlock(l,al)if al.status==0 then al.status=al.write(l,al.data)end end;function f:DumpChar(am,al)self:DumpBlock(string.char(am),al)end;function f:DumpInt(x,al)self:DumpBlock(self:from_int(x),al)end;function f:DumpSizeT(x,al)self:DumpBlock(self:from_int(x),al)if h==8 then self:DumpBlock(self:from_int(0),al)end end;function f:DumpNumber(x,al)self:DumpBlock(self:from_double(x),al)end;function f:DumpString(O,al)if O==nil then self:DumpSizeT(0,al)else O=O.."\0"self:DumpSizeT(#O,al)self:DumpBlock(O,al)end end;function f:DumpCode(an,al)local s=an.sizecode;self:DumpInt(s,al)for Y=0,s-1 do self:DumpBlock(e:Instruction(an.code[Y]),al)end end;function f:DumpConstants(an,al)local s=an.sizek;self:DumpInt(s,al)for Y=0,s-1 do local _=an.k[Y]local ag=self:ttype(_)self:DumpChar(ag,al)if ag==self.LUA_TNIL then elseif ag==self.LUA_TBOOLEAN then self:DumpChar(_.value and 1 or 0,al)elseif ag==self.LUA_TNUMBER then self:DumpNumber(_.value,al)elseif ag==self.LUA_TSTRING then self:DumpString(_.value,al)else end end;s=an.sizep;self:DumpInt(s,al)for Y=0,s-1 do self:DumpFunction(an.p[Y],an.source,al)end end;function f:DumpDebug(an,al)local s;s=al.strip and 0 or an.sizelineinfo;self:DumpInt(s,al)for Y=0,s-1 do self:DumpInt(an.lineinfo[Y],al)end;s=al.strip and 0 or an.sizelocvars;self:DumpInt(s,al)for Y=0,s-1 do self:DumpString(an.locvars[Y].varname,al)self:DumpInt(an.locvars[Y].startpc,al)self:DumpInt(an.locvars[Y].endpc,al)end;s=al.strip and 0 or an.sizeupvalues;self:DumpInt(s,al)for Y=0,s-1 do self:DumpString(an.upvalues[Y],al)end end;function f:DumpFunction(an,t,al)local n=an.source;if n==t or al.strip then n=nil end;self:DumpString(n,al)self:DumpInt(an.lineDefined,al)self:DumpInt(an.lastlinedefined,al)self:DumpChar(an.nups,al)self:DumpChar(an.numparams,al)self:DumpChar(an.is_vararg,al)self:DumpChar(an.maxstacksize,al)self:DumpCode(an,al)self:DumpConstants(an,al)self:DumpDebug(an,al)end;function f:DumpHeader(al)local ao=self:header()assert(#ao==self.LUAC_HEADERSIZE)self:DumpBlock(ao,al)end;function f:header()local x=1;return self.LUA_SIGNATURE..string.char(self.LUAC_VERSION,self.LUAC_FORMAT,x,4,h,4,8,0)end;function f:dump(L,an,ap,m,aq)local al={}al.L=L;al.write=ap;al.data=m;al.strip=aq;al.status=0;self:DumpHeader(al)self:DumpFunction(an,nil,al)al.write(nil,al.data)return al.status end;g.MAXSTACK=250;function g:ttisnumber(_)if _ then return type(_.value)=="number"else return false end end;function g:nvalue(_)return _.value end;function g:setnilvalue(_)_.value=nil end;function g:setsvalue(_,x)_.value=x end;g.setnvalue=g.setsvalue;g.sethvalue=g.setsvalue;g.setbvalue=g.setsvalue;function g:numadd(a1,l)return a1+l end;function g:numsub(a1,l)return a1-l end;function g:nummul(a1,l)return a1*l end;function g:numdiv(a1,l)return a1/l end;function g:nummod(a1,l)return a1%l end;function g:numpow(a1,l)return a1^l end;function g:numunm(a1)return-a1 end;function g:numisnan(a1)return not a1==a1 end;g.NO_JUMP=-1;g.BinOpr={OPR_ADD=0,OPR_SUB=1,OPR_MUL=2,OPR_DIV=3,OPR_MOD=4,OPR_POW=5,OPR_CONCAT=6,OPR_NE=7,OPR_EQ=8,OPR_LT=9,OPR_LE=10,OPR_GT=11,OPR_GE=12,OPR_AND=13,OPR_OR=14,OPR_NOBINOPR=15}g.UnOpr={OPR_MINUS=0,OPR_NOT=1,OPR_LEN=2,OPR_NOUNOPR=3}function g:getcode(ar,as)return ar.f.code[as.info]end;function g:codeAsBx(ar,_,at,au)return self:codeABx(ar,_,at,au+e.MAXARG_sBx)end;function g:setmultret(ar,as)self:setreturns(ar,as,c.LUA_MULTRET)end;function g:hasjumps(as)return as.t~=as.f end;function g:isnumeral(as)return as.k=="VKNUM"and as.t==self.NO_JUMP and as.f==self.NO_JUMP end;function g:_nil(ar,Q,s)if ar.pc>ar.lasttarget then if ar.pc==0 then if Q>=ar.nactvar then return end else local av=ar.f.code[ar.pc-1]if e:GET_OPCODE(av)=="OP_LOADNIL"then local aw=e:GETARG_A(av)local ax=e:GETARG_B(av)if aw<=Q and Q<=ax+1 then if Q+s-1>ax then e:SETARG_B(av,Q+s-1)end;return end end end end;self:codeABC(ar,"OP_LOADNIL",Q,Q+s-1,0)end;function g:jump(ar)local ay=ar.jpc;ar.jpc=self.NO_JUMP;local az=self:codeAsBx(ar,"OP_JMP",0,self.NO_JUMP)az=self:concat(ar,az,ay)return az end;function g:ret(ar,D,aA)self:codeABC(ar,"OP_RETURN",D,aA+1,0)end;function g:condjump(ar,a9,at,aB,aC)self:codeABC(ar,a9,at,aB,aC)return self:jump(ar)end;function g:fixjump(ar,aD,aE)local aF=ar.f.code[aD]local aG=aE-(aD+1)i(aE~=self.NO_JUMP)if math.abs(aG)>e.MAXARG_sBx then d:syntaxerror(ar.ls,"control structure too long")end;e:SETARG_sBx(aF,aG)end;function g:getlabel(ar)ar.lasttarget=ar.pc;return ar.pc end;function g:getjump(ar,aD)local aG=e:GETARG_sBx(ar.f.code[aD])if aG==self.NO_JUMP then return self.NO_JUMP else return aD+1+aG end end;function g:getjumpcontrol(ar,aD)local aH=ar.f.code[aD]local aI=ar.f.code[aD-1]if aD>=1 and e:testTMode(e:GET_OPCODE(aI))~=0 then return aI else return aH end end;function g:need_value(ar,aJ)while aJ~=self.NO_JUMP do local Y=self:getjumpcontrol(ar,aJ)if e:GET_OPCODE(Y)~="OP_TESTSET"then return true end;aJ=self:getjump(ar,aJ)end;return false end;function g:patchtestreg(ar,aK,aL)local Y=self:getjumpcontrol(ar,aK)if e:GET_OPCODE(Y)~="OP_TESTSET"then return false end;if aL~=e.NO_REG and aL~=e:GETARG_B(Y)then e:SETARG_A(Y,aL)else e:SET_OPCODE(Y,"OP_TEST")local l=e:GETARG_B(Y)e:SETARG_A(Y,l)e:SETARG_B(Y,0)end;return true end;function g:removevalues(ar,aJ)while aJ~=self.NO_JUMP do self:patchtestreg(ar,aJ,e.NO_REG)aJ=self:getjump(ar,aJ)end end;function g:patchlistaux(ar,aJ,aM,aL,aN)while aJ~=self.NO_JUMP do local aO=self:getjump(ar,aJ)if self:patchtestreg(ar,aJ,aL)then self:fixjump(ar,aJ,aM)else self:fixjump(ar,aJ,aN)end;aJ=aO end end;function g:dischargejpc(ar)self:patchlistaux(ar,ar.jpc,ar.pc,e.NO_REG,ar.pc)ar.jpc=self.NO_JUMP end;function g:patchlist(ar,aJ,aP)if aP==ar.pc then self:patchtohere(ar,aJ)else i(aP<ar.pc)self:patchlistaux(ar,aJ,aP,e.NO_REG,aP)end end;function g:patchtohere(ar,aJ)self:getlabel(ar)ar.jpc=self:concat(ar,ar.jpc,aJ)end;function g:concat(ar,aQ,aR)if aR==self.NO_JUMP then return aQ elseif aQ==self.NO_JUMP then return aR else local aJ=aQ;local aO=self:getjump(ar,aJ)while aO~=self.NO_JUMP do aJ=aO;aO=self:getjump(ar,aJ)end;self:fixjump(ar,aJ,aR)end;return aQ end;function g:checkstack(ar,s)local aS=ar.freereg+s;if aS>ar.f.maxstacksize then if aS>=self.MAXSTACK then d:syntaxerror(ar.ls,"function or expression too complex")end;ar.f.maxstacksize=aS end end;function g:reserveregs(ar,s)self:checkstack(ar,s)ar.freereg=ar.freereg+s end;function g:freereg(ar,aL)if not e:ISK(aL)and aL>=ar.nactvar then ar.freereg=ar.freereg-1;i(aL==ar.freereg)end end;function g:freeexp(ar,as)if as.k=="VNONRELOC"then self:freereg(ar,as.info)end end;function g:addk(ar,aT,w)local L=ar.L;local aU=ar.h[aT.value]local an=ar.f;if self:ttisnumber(aU)then return self:nvalue(aU)else aU={}self:setnvalue(aU,ar.nk)ar.h[aT.value]=aU;c:growvector(L,an.k,ar.nk,an.sizek,nil,e.MAXARG_Bx,"constant table overflow")an.k[ar.nk]=w;local aV=ar.nk;ar.nk=ar.nk+1;return aV end end;function g:stringK(ar,O)local _={}self:setsvalue(_,O)return self:addk(ar,_,_)end;function g:numberK(ar,ab)local _={}self:setnvalue(_,ab)return self:addk(ar,_,_)end;function g:boolK(ar,l)local _={}self:setbvalue(_,l)return self:addk(ar,_,_)end;function g:nilK(ar)local aT,w={},{}self:setnilvalue(w)self:sethvalue(aT,ar.h)return self:addk(ar,aT,w)end;function g:setreturns(ar,as,aW)if as.k=="VCALL"then e:SETARG_C(self:getcode(ar,as),aW+1)elseif as.k=="VVARARG"then e:SETARG_B(self:getcode(ar,as),aW+1)e:SETARG_A(self:getcode(ar,as),ar.freereg)g:reserveregs(ar,1)end end;function g:setoneret(ar,as)if as.k=="VCALL"then as.k="VNONRELOC"as.info=e:GETARG_A(self:getcode(ar,as))elseif as.k=="VVARARG"then e:SETARG_B(self:getcode(ar,as),2)as.k="VRELOCABLE"end end;function g:dischargevars(ar,as)local aT=as.k;if aT=="VLOCAL"then as.k="VNONRELOC"elseif aT=="VUPVAL"then as.info=self:codeABC(ar,"OP_GETUPVAL",0,as.info,0)as.k="VRELOCABLE"elseif aT=="VGLOBAL"then as.info=self:codeABx(ar,"OP_GETGLOBAL",0,as.info)as.k="VRELOCABLE"elseif aT=="VINDEXED"then self:freereg(ar,as.aux)self:freereg(ar,as.info)as.info=self:codeABC(ar,"OP_GETTABLE",0,as.info,as.aux)as.k="VRELOCABLE"elseif aT=="VVARARG"or aT=="VCALL"then self:setoneret(ar,as)else end end;function g:code_label(ar,at,l,aX)self:getlabel(ar)return self:codeABC(ar,"OP_LOADBOOL",at,l,aX)end;function g:discharge2reg(ar,as,aL)self:dischargevars(ar,as)local aT=as.k;if aT=="VNIL"then self:_nil(ar,aL,1)elseif aT=="VFALSE"or aT=="VTRUE"then self:codeABC(ar,"OP_LOADBOOL",aL,as.k=="VTRUE"and 1 or 0,0)elseif aT=="VK"then self:codeABx(ar,"OP_LOADK",aL,as.info)elseif aT=="VKNUM"then self:codeABx(ar,"OP_LOADK",aL,self:numberK(ar,as.nval))elseif aT=="VRELOCABLE"then local aD=self:getcode(ar,as)e:SETARG_A(aD,aL)elseif aT=="VNONRELOC"then if aL~=as.info then self:codeABC(ar,"OP_MOVE",aL,as.info,0)end else i(as.k=="VVOID"or as.k=="VJMP")return end;as.info=aL;as.k="VNONRELOC"end;function g:discharge2anyreg(ar,as)if as.k~="VNONRELOC"then self:reserveregs(ar,1)self:discharge2reg(ar,as,ar.freereg-1)end end;function g:exp2reg(ar,as,aL)self:discharge2reg(ar,as,aL)if as.k=="VJMP"then as.t=self:concat(ar,as.t,as.info)end;if self:hasjumps(as)then local aY;local aZ=self.NO_JUMP;local a_=self.NO_JUMP;if self:need_value(ar,as.t)or self:need_value(ar,as.f)then local b0=as.k=="VJMP"and self.NO_JUMP or self:jump(ar)aZ=self:code_label(ar,aL,0,1)a_=self:code_label(ar,aL,1,0)self:patchtohere(ar,b0)end;aY=self:getlabel(ar)self:patchlistaux(ar,as.f,aY,aL,aZ)self:patchlistaux(ar,as.t,aY,aL,a_)end;as.f,as.t=self.NO_JUMP,self.NO_JUMP;as.info=aL;as.k="VNONRELOC"end;function g:exp2nextreg(ar,as)self:dischargevars(ar,as)self:freeexp(ar,as)self:reserveregs(ar,1)self:exp2reg(ar,as,ar.freereg-1)end;function g:exp2anyreg(ar,as)self:dischargevars(ar,as)if as.k=="VNONRELOC"then if not self:hasjumps(as)then return as.info end;if as.info>=ar.nactvar then self:exp2reg(ar,as,as.info)return as.info end end;self:exp2nextreg(ar,as)return as.info end;function g:exp2val(ar,as)if self:hasjumps(as)then self:exp2anyreg(ar,as)else self:dischargevars(ar,as)end end;function g:exp2RK(ar,as)self:exp2val(ar,as)local aT=as.k;if aT=="VKNUM"or aT=="VTRUE"or aT=="VFALSE"or aT=="VNIL"then if ar.nk<=e.MAXINDEXRK then if as.k=="VNIL"then as.info=self:nilK(ar)else as.info=as.k=="VKNUM"and self:numberK(ar,as.nval)or self:boolK(ar,as.k=="VTRUE")end;as.k="VK"return e:RKASK(as.info)end elseif aT=="VK"then if as.info<=e.MAXINDEXRK then return e:RKASK(as.info)end else end;return self:exp2anyreg(ar,as)end;function g:storevar(ar,b1,b2)local aT=b1.k;if aT=="VLOCAL"then self:freeexp(ar,b2)self:exp2reg(ar,b2,b1.info)return elseif aT=="VUPVAL"then local as=self:exp2anyreg(ar,b2)self:codeABC(ar,"OP_SETUPVAL",as,b1.info,0)elseif aT=="VGLOBAL"then local as=self:exp2anyreg(ar,b2)self:codeABx(ar,"OP_SETGLOBAL",as,b1.info)elseif aT=="VINDEXED"then local as=self:exp2RK(ar,b2)self:codeABC(ar,"OP_SETTABLE",b1.info,b1.aux,as)else i(0)end;self:freeexp(ar,b2)end;function g:_self(ar,as,b3)self:exp2anyreg(ar,as)self:freeexp(ar,as)local b4=ar.freereg;self:reserveregs(ar,2)self:codeABC(ar,"OP_SELF",b4,as.info,self:exp2RK(ar,b3))self:freeexp(ar,b3)as.info=b4;as.k="VNONRELOC"end;function g:invertjump(ar,as)local aD=self:getjumpcontrol(ar,as.info)i(e:testTMode(e:GET_OPCODE(aD))~=0 and e:GET_OPCODE(aD)~="OP_TESTSET"and e:GET_OPCODE(aD)~="OP_TEST")e:SETARG_A(aD,e:GETARG_A(aD)==0 and 1 or 0)end;function g:jumponcond(ar,as,b5)if as.k=="VRELOCABLE"then local b6=self:getcode(ar,as)if e:GET_OPCODE(b6)=="OP_NOT"then ar.pc=ar.pc-1;return self:condjump(ar,"OP_TEST",e:GETARG_B(b6),0,b5 and 0 or 1)end end;self:discharge2anyreg(ar,as)self:freeexp(ar,as)return self:condjump(ar,"OP_TESTSET",e.NO_REG,as.info,b5 and 1 or 0)end;function g:goiftrue(ar,as)local aD;self:dischargevars(ar,as)local aT=as.k;if aT=="VK"or aT=="VKNUM"or aT=="VTRUE"then aD=self.NO_JUMP elseif aT=="VFALSE"then aD=self:jump(ar)elseif aT=="VJMP"then self:invertjump(ar,as)aD=as.info else aD=self:jumponcond(ar,as,false)end;as.f=self:concat(ar,as.f,aD)self:patchtohere(ar,as.t)as.t=self.NO_JUMP end;function g:goiffalse(ar,as)local aD;self:dischargevars(ar,as)local aT=as.k;if aT=="VNIL"or aT=="VFALSE"then aD=self.NO_JUMP elseif aT=="VTRUE"then aD=self:jump(ar)elseif aT=="VJMP"then aD=as.info else aD=self:jumponcond(ar,as,true)end;as.t=self:concat(ar,as.t,aD)self:patchtohere(ar,as.f)as.f=self.NO_JUMP end;function g:codenot(ar,as)self:dischargevars(ar,as)local aT=as.k;if aT=="VNIL"or aT=="VFALSE"then as.k="VTRUE"elseif aT=="VK"or aT=="VKNUM"or aT=="VTRUE"then as.k="VFALSE"elseif aT=="VJMP"then self:invertjump(ar,as)elseif aT=="VRELOCABLE"or aT=="VNONRELOC"then self:discharge2anyreg(ar,as)self:freeexp(ar,as)as.info=self:codeABC(ar,"OP_NOT",0,as.info,0)as.k="VRELOCABLE"else i(0)end;as.f,as.t=as.t,as.f;self:removevalues(ar,as.f)self:removevalues(ar,as.t)end;function g:indexed(ar,ad,aT)ad.aux=self:exp2RK(ar,aT)ad.k="VINDEXED"end;function g:constfolding(a9,b7,b8)local ab;if not self:isnumeral(b7)or not self:isnumeral(b8)then return false end;local b9=b7.nval;local ba=b8.nval;if a9=="OP_ADD"then ab=self:numadd(b9,ba)elseif a9=="OP_SUB"then ab=self:numsub(b9,ba)elseif a9=="OP_MUL"then ab=self:nummul(b9,ba)elseif a9=="OP_DIV"then if ba==0 then return false end;ab=self:numdiv(b9,ba)elseif a9=="OP_MOD"then if ba==0 then return false end;ab=self:nummod(b9,ba)elseif a9=="OP_POW"then ab=self:numpow(b9,ba)elseif a9=="OP_UNM"then ab=self:numunm(b9)elseif a9=="OP_LEN"then return false else i(0)ab=0 end;if self:numisnan(ab)then return false end;b7.nval=ab;return true end;function g:codearith(ar,a9,b7,b8)if self:constfolding(a9,b7,b8)then return else local bb=a9~="OP_UNM"and a9~="OP_LEN"and self:exp2RK(ar,b8)or 0;local bc=self:exp2RK(ar,b7)if bc>bb then self:freeexp(ar,b7)self:freeexp(ar,b8)else self:freeexp(ar,b8)self:freeexp(ar,b7)end;b7.info=self:codeABC(ar,a9,0,bc,bb)b7.k="VRELOCABLE"end end;function g:codecomp(ar,a9,b5,b7,b8)local bc=self:exp2RK(ar,b7)local bb=self:exp2RK(ar,b8)self:freeexp(ar,b8)self:freeexp(ar,b7)if b5==0 and a9~="OP_EQ"then bc,bb=bb,bc;b5=1 end;b7.info=self:condjump(ar,a9,b5,bc,bb)b7.k="VJMP"end;function g:prefix(ar,a9,as)local b8={}b8.t,b8.f=self.NO_JUMP,self.NO_JUMP;b8.k="VKNUM"b8.nval=0;if a9=="OPR_MINUS"then if not self:isnumeral(as)then self:exp2anyreg(ar,as)end;self:codearith(ar,"OP_UNM",as,b8)elseif a9=="OPR_NOT"then self:codenot(ar,as)elseif a9=="OPR_LEN"then self:exp2anyreg(ar,as)self:codearith(ar,"OP_LEN",as,b8)else i(0)end end;function g:infix(ar,a9,w)if a9=="OPR_AND"then self:goiftrue(ar,w)elseif a9=="OPR_OR"then self:goiffalse(ar,w)elseif a9=="OPR_CONCAT"then self:exp2nextreg(ar,w)elseif a9=="OPR_ADD"or a9=="OPR_SUB"or a9=="OPR_MUL"or a9=="OPR_DIV"or a9=="OPR_MOD"or a9=="OPR_POW"then if not self:isnumeral(w)then self:exp2RK(ar,w)end else self:exp2RK(ar,w)end end;g.arith_op={OPR_ADD="OP_ADD",OPR_SUB="OP_SUB",OPR_MUL="OP_MUL",OPR_DIV="OP_DIV",OPR_MOD="OP_MOD",OPR_POW="OP_POW"}g.comp_op={OPR_EQ="OP_EQ",OPR_NE="OP_EQ",OPR_LT="OP_LT",OPR_LE="OP_LE",OPR_GT="OP_LT",OPR_GE="OP_LE"}g.comp_cond={OPR_EQ=1,OPR_NE=0,OPR_LT=1,OPR_LE=1,OPR_GT=0,OPR_GE=0}function g:posfix(ar,a9,b7,b8)local function bd(b7,b8)b7.k=b8.k;b7.info=b8.info;b7.aux=b8.aux;b7.nval=b8.nval;b7.t=b8.t;b7.f=b8.f end;if a9=="OPR_AND"then i(b7.t==self.NO_JUMP)self:dischargevars(ar,b8)b8.f=self:concat(ar,b8.f,b7.f)bd(b7,b8)elseif a9=="OPR_OR"then i(b7.f==self.NO_JUMP)self:dischargevars(ar,b8)b8.t=self:concat(ar,b8.t,b7.t)bd(b7,b8)elseif a9=="OPR_CONCAT"then self:exp2val(ar,b8)if b8.k=="VRELOCABLE"and e:GET_OPCODE(self:getcode(ar,b8))=="OP_CONCAT"then i(b7.info==e:GETARG_B(self:getcode(ar,b8))-1)self:freeexp(ar,b7)e:SETARG_B(self:getcode(ar,b8),b7.info)b7.k="VRELOCABLE"b7.info=b8.info else self:exp2nextreg(ar,b8)self:codearith(ar,"OP_CONCAT",b7,b8)end else local be=self.arith_op[a9]if be then self:codearith(ar,be,b7,b8)else local bf=self.comp_op[a9]if bf then self:codecomp(ar,bf,self.comp_cond[a9],b7,b8)else i(0)end end end end;function g:fixline(ar,bg)ar.f.lineinfo[ar.pc-1]=bg end;function g:code(ar,Y,bg)local an=ar.f;self:dischargejpc(ar)c:growvector(ar.L,an.code,ar.pc,an.sizecode,nil,c.MAX_INT,"code size overflow")an.code[ar.pc]=Y;c:growvector(ar.L,an.lineinfo,ar.pc,an.sizelineinfo,nil,c.MAX_INT,"code size overflow")an.lineinfo[ar.pc]=bg;local aD=ar.pc;ar.pc=ar.pc+1;return aD end;function g:codeABC(ar,_,a1,l,N)i(e:getOpMode(_)==e.OpMode.iABC)i(e:getBMode(_)~=e.OpArgMask.OpArgN or l==0)i(e:getCMode(_)~=e.OpArgMask.OpArgN or N==0)return self:code(ar,e:CREATE_ABC(_,a1,l,N),ar.ls.lastline)end;function g:codeABx(ar,_,a1,a2)i(e:getOpMode(_)==e.OpMode.iABx or e:getOpMode(_)==e.OpMode.iAsBx)i(e:getCMode(_)==e.OpArgMask.OpArgN)return self:code(ar,e:CREATE_ABx(_,a1,a2),ar.ls.lastline)end;function g:setlist(ar,bh,bi,bj)local N=math.floor((bi-1)/e.LFIELDS_PER_FLUSH)+1;local l=bj==c.LUA_MULTRET and 0 or bj;i(bj~=0)if N<=e.MAXARG_C then self:codeABC(ar,"OP_SETLIST",bh,l,N)else self:codeABC(ar,"OP_SETLIST",bh,l,0)self:code(ar,e:CREATE_Inst(N),ar.ls.lastline)end;ar.freereg=bh+1 end;c.LUA_QS=d.LUA_QS or"'%s'"c.SHRT_MAX=32767;c.LUAI_MAXVARS=200;c.LUAI_MAXUPVALUES=60;c.MAX_INT=d.MAX_INT or 2147483645;c.LUAI_MAXCCALLS=200;c.VARARG_HASARG=1;c.HASARG_MASK=2;c.VARARG_ISVARARG=2;c.VARARG_NEEDSARG=4;c.LUA_MULTRET=-1;function c:LUA_QL(x)return"'"..x.."'"end;function c:growvector(L,w,bi,bk,ad,bl,as)if bi>=bl then error(as)end end;function c:newproto(L)local an={}an.k={}an.sizek=0;an.p={}an.sizep=0;an.code={}an.sizecode=0;an.sizelineinfo=0;an.sizeupvalues=0;an.nups=0;an.upvalues={}an.numparams=0;an.is_vararg=0;an.maxstacksize=0;an.lineinfo={}an.sizelocvars=0;an.locvars={}an.lineDefined=0;an.lastlinedefined=0;an.source=nil;return an end;function c:int2fb(x)local as=0;while x>=16 do x=math.floor((x+1)/2)as=as+1 end;if x<8 then return x else return(as+1)*8+x-8 end end;function c:hasmultret(aT)return aT=="VCALL"or aT=="VVARARG"end;function c:getlocvar(ar,Y)return ar.f.locvars[ar.actvar[Y]]end;function c:checklimit(ar,w,E,ac)if w>E then self:errorlimit(ar,E,ac)end end;function c:anchor_token(G)if G.t.token=="TK_NAME"or G.t.token=="TK_STRING"then end end;function c:error_expected(G,H)d:syntaxerror(G,string.format(self.LUA_QS.." expected",d:token2str(G,H)))end;function c:errorlimit(ar,bl,bm)local I=ar.f.linedefined==0 and string.format("main function has more than %d %s",bl,bm)or string.format("function at line %d has more than %d %s",ar.f.linedefined,bl,bm)d:lexerror(ar.ls,I,0)end;function c:testnext(G,N)if G.t.token==N then d:next(G)return true else return false end end;function c:check(G,N)if G.t.token~=N then self:error_expected(G,N)end end;function c:checknext(G,N)self:check(G,N)d:next(G)end;function c:check_condition(G,N,I)if not N then d:syntaxerror(G,I)end end;function c:check_match(G,bm,bn,bo)if not self:testnext(G,bm)then if bo==G.linenumber then self:error_expected(G,bm)else d:syntaxerror(G,string.format(self.LUA_QS.." expected (to close "..self.LUA_QS.." at line %d)",d:token2str(G,bm),d:token2str(G,bn),bo))end end end;function c:str_checkname(G)self:check(G,"TK_NAME")local Z=G.t.seminfo;d:next(G)return Z end;function c:init_exp(as,aT,Y)as.f,as.t=g.NO_JUMP,g.NO_JUMP;as.k=aT;as.info=Y end;function c:codestring(G,as,O)self:init_exp(as,"VK",g:stringK(G.fs,O))end;function c:checkname(G,as)self:codestring(G,as,self:str_checkname(G))end;function c:registerlocalvar(G,bp)local ar=G.fs;local an=ar.f;self:growvector(G.L,an.locvars,ar.nlocvars,an.sizelocvars,nil,self.SHRT_MAX,"too many local variables")an.locvars[ar.nlocvars]={}an.locvars[ar.nlocvars].varname=bp;local bq=ar.nlocvars;ar.nlocvars=ar.nlocvars+1;return bq end;function c:new_localvarliteral(G,w,s)self:new_localvar(G,w,s)end;function c:new_localvar(G,name,s)local ar=G.fs;self:checklimit(ar,ar.nactvar+s+1,self.LUAI_MAXVARS,"local variables")ar.actvar[ar.nactvar+s]=self:registerlocalvar(G,name)end;function c:adjustlocalvars(G,br)local ar=G.fs;ar.nactvar=ar.nactvar+br;for Y=br,1,-1 do self:getlocvar(ar,ar.nactvar-Y).startpc=ar.pc end end;function c:removevars(G,bs)local ar=G.fs;while ar.nactvar>bs do ar.nactvar=ar.nactvar-1;self:getlocvar(ar,ar.nactvar).endpc=ar.pc end end;function c:indexupvalue(ar,name,w)local an=ar.f;for Y=0,an.nups-1 do if ar.upvalues[Y].k==w.k and ar.upvalues[Y].info==w.info then i(an.upvalues[Y]==name)return Y end end;self:checklimit(ar,an.nups+1,self.LUAI_MAXUPVALUES,"upvalues")self:growvector(ar.L,an.upvalues,an.nups,an.sizeupvalues,nil,self.MAX_INT,"")an.upvalues[an.nups]=name;i(w.k=="VLOCAL"or w.k=="VUPVAL")ar.upvalues[an.nups]={k=w.k,info=w.info}local bt=an.nups;an.nups=an.nups+1;return bt end;function c:searchvar(ar,s)for Y=ar.nactvar-1,0,-1 do if s==self:getlocvar(ar,Y).varname then return Y end end;return-1 end;function c:markupval(ar,bu)local bv=ar.bl;while bv and bv.nactvar>bu do bv=bv.previous end;if bv then bv.upval=true end end;function c:singlevaraux(ar,s,b1,bh)if ar==nil then self:init_exp(b1,"VGLOBAL",e.NO_REG)return"VGLOBAL"else local w=self:searchvar(ar,s)if w>=0 then self:init_exp(b1,"VLOCAL",w)if bh==0 then self:markupval(ar,w)end;return"VLOCAL"else if self:singlevaraux(ar.prev,s,b1,0)=="VGLOBAL"then return"VGLOBAL"end;b1.info=self:indexupvalue(ar,s,b1)b1.k="VUPVAL"return"VUPVAL"end end end;function c:singlevar(G,b1)local bp=self:str_checkname(G)local ar=G.fs;if self:singlevaraux(ar,bp,b1,1)=="VGLOBAL"then b1.info=g:stringK(ar,bp)end end;function c:adjust_assign(G,br,bw,as)local ar=G.fs;local bx=br-bw;if self:hasmultret(as.k)then bx=bx+1;if bx<=0 then bx=0 end;g:setreturns(ar,as,bx)if bx>1 then g:reserveregs(ar,bx-1)end else if as.k~="VVOID"then g:exp2nextreg(ar,as)end;if bx>0 then local aL=ar.freereg;g:reserveregs(ar,bx)g:_nil(ar,aL,bx)end end end;function c:enterlevel(G)G.L.nCcalls=G.L.nCcalls+1;if G.L.nCcalls>self.LUAI_MAXCCALLS then d:lexerror(G,"chunk has too many syntax levels",0)end end;function c:leavelevel(G)G.L.nCcalls=G.L.nCcalls-1 end;function c:enterblock(ar,bv,by)bv.breaklist=g.NO_JUMP;bv.isbreakable=by;bv.nactvar=ar.nactvar;bv.upval=false;bv.previous=ar.bl;ar.bl=bv;i(ar.freereg==ar.nactvar)end;function c:leaveblock(ar)local bv=ar.bl;ar.bl=bv.previous;self:removevars(ar.ls,bv.nactvar)if bv.upval then g:codeABC(ar,"OP_CLOSE",bv.nactvar,0,0)end;i(not bv.isbreakable or not bv.upval)i(bv.nactvar==ar.nactvar)ar.freereg=ar.nactvar;g:patchtohere(ar,bv.breaklist)end;function c:pushclosure(G,b4,w)local ar=G.fs;local an=ar.f;self:growvector(G.L,an.p,ar.np,an.sizep,nil,e.MAXARG_Bx,"constant table overflow")an.p[ar.np]=b4.f;ar.np=ar.np+1;self:init_exp(w,"VRELOCABLE",g:codeABx(ar,"OP_CLOSURE",0,ar.np-1))for Y=0,b4.f.nups-1 do local _=b4.upvalues[Y].k=="VLOCAL"and"OP_MOVE"or"OP_GETUPVAL"g:codeABC(ar,_,0,b4.upvalues[Y].info,0)end end;function c:open_func(G,ar)local L=G.L;local an=self:newproto(G.L)ar.f=an;ar.prev=G.fs;ar.ls=G;ar.L=L;G.fs=ar;ar.pc=0;ar.lasttarget=-1;ar.jpc=g.NO_JUMP;ar.freereg=0;ar.nk=0;ar.np=0;ar.nlocvars=0;ar.nactvar=0;ar.bl=nil;an.source=G.source;an.maxstacksize=2;ar.h={}end;function c:close_func(G)local L=G.L;local ar=G.fs;local an=ar.f;self:removevars(G,0)g:ret(ar,0,0)an.sizecode=ar.pc;an.sizelineinfo=ar.pc;an.sizek=ar.nk;an.sizep=ar.np;an.sizelocvars=ar.nlocvars;an.sizeupvalues=an.nups;i(ar.bl==nil)G.fs=ar.prev;if ar then self:anchor_token(G)end end;function c:parser(L,r,k,name)local bz={}bz.t={}bz.lookahead={}local bA={}bA.upvalues={}bA.actvar={}L.nCcalls=0;bz.buff=k;d:setinput(L,bz,r,name)self:open_func(bz,bA)bA.f.is_vararg=self.VARARG_ISVARARG;d:next(bz)self:chunk(bz)self:check(bz,"TK_EOS")self:close_func(bz)i(bA.prev==nil)i(bA.f.nups==0)i(bz.fs==nil)return bA.f end;function c:field(G,w)local ar=G.fs;local b3={}g:exp2anyreg(ar,w)d:next(G)self:checkname(G,b3)g:indexed(ar,w,b3)end;function c:yindex(G,w)d:next(G)self:expr(G,w)g:exp2val(G.fs,w)self:checknext(G,"]")end;function c:recfield(G,bB)local ar=G.fs;local aL=G.fs.freereg;local b3,bC={},{}if G.t.token=="TK_NAME"then self:checklimit(ar,bB.nh,self.MAX_INT,"items in a constructor")self:checkname(G,b3)else self:yindex(G,b3)end;bB.nh=bB.nh+1;self:checknext(G,"=")local bD=g:exp2RK(ar,b3)self:expr(G,bC)g:codeABC(ar,"OP_SETTABLE",bB.t.info,bD,g:exp2RK(ar,bC))ar.freereg=aL end;function c:closelistfield(ar,bB)if bB.v.k=="VVOID"then return end;g:exp2nextreg(ar,bB.v)bB.v.k="VVOID"if bB.tostore==e.LFIELDS_PER_FLUSH then g:setlist(ar,bB.t.info,bB.na,bB.tostore)bB.tostore=0 end end;function c:lastlistfield(ar,bB)if bB.tostore==0 then return end;if self:hasmultret(bB.v.k)then g:setmultret(ar,bB.v)g:setlist(ar,bB.t.info,bB.na,self.LUA_MULTRET)bB.na=bB.na-1 else if bB.v.k~="VVOID"then g:exp2nextreg(ar,bB.v)end;g:setlist(ar,bB.t.info,bB.na,bB.tostore)end end;function c:listfield(G,bB)self:expr(G,bB.v)self:checklimit(G.fs,bB.na,self.MAX_INT,"items in a constructor")bB.na=bB.na+1;bB.tostore=bB.tostore+1 end;function c:constructor(G,ad)local ar=G.fs;local bg=G.linenumber;local aD=g:codeABC(ar,"OP_NEWTABLE",0,0,0)local bB={}bB.v={}bB.na,bB.nh,bB.tostore=0,0,0;bB.t=ad;self:init_exp(ad,"VRELOCABLE",aD)self:init_exp(bB.v,"VVOID",0)g:exp2nextreg(G.fs,ad)self:checknext(G,"{")repeat i(bB.v.k=="VVOID"or bB.tostore>0)if G.t.token=="}"then break end;self:closelistfield(ar,bB)local N=G.t.token;if N=="TK_NAME"then d:lookahead(G)if G.lookahead.token~="="then self:listfield(G,bB)else self:recfield(G,bB)end elseif N=="["then self:recfield(G,bB)else self:listfield(G,bB)end until not self:testnext(G,",")and not self:testnext(G,";")self:check_match(G,"}","{",bg)self:lastlistfield(ar,bB)e:SETARG_B(ar.f.code[aD],self:int2fb(bB.na))e:SETARG_C(ar.f.code[aD],self:int2fb(bB.nh))end;function c:parlist(G)local ar=G.fs;local an=ar.f;local bE=0;an.is_vararg=0;if G.t.token~=")"then repeat local N=G.t.token;if N=="TK_NAME"then self:new_localvar(G,self:str_checkname(G),bE)bE=bE+1 elseif N=="TK_DOTS"then d:next(G)self:new_localvarliteral(G,"arg",bE)bE=bE+1;an.is_vararg=self.VARARG_HASARG+self.VARARG_NEEDSARG;an.is_vararg=an.is_vararg+self.VARARG_ISVARARG else d:syntaxerror(G,"<name> or "..self:LUA_QL("...").." expected")end until an.is_vararg~=0 or not self:testnext(G,",")end;self:adjustlocalvars(G,bE)an.numparams=ar.nactvar-an.is_vararg%self.HASARG_MASK;g:reserveregs(ar,ar.nactvar)end;function c:body(G,as,bF,bg)local bG={}bG.upvalues={}bG.actvar={}self:open_func(G,bG)bG.f.lineDefined=bg;self:checknext(G,"(")if bF then self:new_localvarliteral(G,"self",0)self:adjustlocalvars(G,1)end;self:parlist(G)self:checknext(G,")")self:chunk(G)bG.f.lastlinedefined=G.linenumber;self:check_match(G,"TK_END","TK_FUNCTION",bg)self:close_func(G)self:pushclosure(G,bG,as)end;function c:explist1(G,w)local s=1;self:expr(G,w)while self:testnext(G,",")do g:exp2nextreg(G.fs,w)self:expr(G,w)s=s+1 end;return s end;function c:funcargs(G,an)local ar=G.fs;local bH={}local bE;local bg=G.linenumber;local N=G.t.token;if N=="("then if bg~=G.lastline then d:syntaxerror(G,"ambiguous syntax (function call x new statement)")end;d:next(G)if G.t.token==")"then bH.k="VVOID"else self:explist1(G,bH)g:setmultret(ar,bH)end;self:check_match(G,")","(",bg)elseif N=="{"then self:constructor(G,bH)elseif N=="TK_STRING"then self:codestring(G,bH,G.t.seminfo)d:next(G)else d:syntaxerror(G,"function arguments expected")return end;i(an.k=="VNONRELOC")local bh=an.info;if self:hasmultret(bH.k)then bE=self.LUA_MULTRET else if bH.k~="VVOID"then g:exp2nextreg(ar,bH)end;bE=ar.freereg-(bh+1)end;self:init_exp(an,"VCALL",g:codeABC(ar,"OP_CALL",bh,bE+1,2))g:fixline(ar,bg)ar.freereg=bh+1 end;function c:prefixexp(G,w)local N=G.t.token;if N=="("then local bg=G.linenumber;d:next(G)self:expr(G,w)self:check_match(G,")","(",bg)g:dischargevars(G.fs,w)elseif N=="TK_NAME"then self:singlevar(G,w)else d:syntaxerror(G,"unexpected symbol")end;return end;function c:primaryexp(G,w)local ar=G.fs;self:prefixexp(G,w)while true do local N=G.t.token;if N=="."then self:field(G,w)elseif N=="["then local b3={}g:exp2anyreg(ar,w)self:yindex(G,b3)g:indexed(ar,w,b3)elseif N==":"then local b3={}d:next(G)self:checkname(G,b3)g:_self(ar,w,b3)self:funcargs(G,w)elseif N=="("or N=="TK_STRING"or N=="{"then g:exp2nextreg(ar,w)self:funcargs(G,w)else return end end end;function c:simpleexp(G,w)local N=G.t.token;if N=="TK_NUMBER"then self:init_exp(w,"VKNUM",0)w.nval=G.t.seminfo elseif N=="TK_STRING"then self:codestring(G,w,G.t.seminfo)elseif N=="TK_NIL"then self:init_exp(w,"VNIL",0)elseif N=="TK_TRUE"then self:init_exp(w,"VTRUE",0)elseif N=="TK_FALSE"then self:init_exp(w,"VFALSE",0)elseif N=="TK_DOTS"then local ar=G.fs;self:check_condition(G,ar.f.is_vararg~=0,"cannot use "..self:LUA_QL("...").." outside a vararg function")local bI=ar.f.is_vararg;if bI>=self.VARARG_NEEDSARG then ar.f.is_vararg=bI-self.VARARG_NEEDSARG end;self:init_exp(w,"VVARARG",g:codeABC(ar,"OP_VARARG",0,1,0))elseif N=="{"then self:constructor(G,w)return elseif N=="TK_FUNCTION"then d:next(G)self:body(G,w,false,G.linenumber)return else self:primaryexp(G,w)return end;d:next(G)end;function c:getunopr(a9)if a9=="TK_NOT"then return"OPR_NOT"elseif a9=="-"then return"OPR_MINUS"elseif a9=="#"then return"OPR_LEN"else return"OPR_NOUNOPR"end end;c.getbinopr_table={["+"]="OPR_ADD",["-"]="OPR_SUB",["*"]="OPR_MUL",["/"]="OPR_DIV",["%"]="OPR_MOD",["^"]="OPR_POW",["TK_CONCAT"]="OPR_CONCAT",["TK_NE"]="OPR_NE",["TK_EQ"]="OPR_EQ",["<"]="OPR_LT",["TK_LE"]="OPR_LE",[">"]="OPR_GT",["TK_GE"]="OPR_GE",["TK_AND"]="OPR_AND",["TK_OR"]="OPR_OR"}function c:getbinopr(a9)local bJ=self.getbinopr_table[a9]if bJ then return bJ else return"OPR_NOBINOPR"end end;c.priority={{6,6},{6,6},{7,7},{7,7},{7,7},{10,9},{5,4},{3,3},{3,3},{3,3},{3,3},{3,3},{3,3},{2,2},{1,1}}c.UNARY_PRIORITY=8;function c:subexpr(G,w,bl)self:enterlevel(G)local bK=self:getunopr(G.t.token)if bK~="OPR_NOUNOPR"then d:next(G)self:subexpr(G,w,self.UNARY_PRIORITY)g:prefix(G.fs,bK,w)else self:simpleexp(G,w)end;local a9=self:getbinopr(G.t.token)while a9~="OPR_NOBINOPR"and self.priority[g.BinOpr[a9]+1][1]>bl do local ba={}d:next(G)g:infix(G.fs,a9,w)local bL=self:subexpr(G,ba,self.priority[g.BinOpr[a9]+1][2])g:posfix(G.fs,a9,w,ba)a9=bL end;self:leavelevel(G)return a9 end;function c:expr(G,w)self:subexpr(G,w,0)end;function c:block_follow(H)if H=="TK_ELSE"or H=="TK_ELSEIF"or H=="TK_END"or H=="TK_UNTIL"or H=="TK_EOS"then return true else return false end end;function c:block(G)local ar=G.fs;local bv={}self:enterblock(ar,bv,false)self:chunk(G)i(bv.breaklist==g.NO_JUMP)self:leaveblock(ar)end;function c:check_conflict(G,bM,w)local ar=G.fs;local bx=ar.freereg;local bN=false;while bM do if bM.v.k=="VINDEXED"then if bM.v.info==w.info then bN=true;bM.v.info=bx end;if bM.v.aux==w.info then bN=true;bM.v.aux=bx end end;bM=bM.prev end;if bN then g:codeABC(ar,"OP_MOVE",ar.freereg,w.info,0)g:reserveregs(ar,1)end end;function c:assignment(G,bM,br)local as={}local N=bM.v.k;self:check_condition(G,N=="VLOCAL"or N=="VUPVAL"or N=="VGLOBAL"or N=="VINDEXED","syntax error")if self:testnext(G,",")then local bO={}bO.v={}bO.prev=bM;self:primaryexp(G,bO.v)if bO.v.k=="VLOCAL"then self:check_conflict(G,bM,bO.v)end;self:checklimit(G.fs,br,self.LUAI_MAXCCALLS-G.L.nCcalls,"variables in assignment")self:assignment(G,bO,br+1)else self:checknext(G,"=")local bw=self:explist1(G,as)if bw~=br then self:adjust_assign(G,br,bw,as)if bw>br then G.fs.freereg=G.fs.freereg-(bw-br)end else g:setoneret(G.fs,as)g:storevar(G.fs,bM.v,as)return end end;self:init_exp(as,"VNONRELOC",G.fs.freereg-1)g:storevar(G.fs,bM.v,as)end;function c:cond(G)local w={}self:expr(G,w)if w.k=="VNIL"then w.k="VFALSE"end;g:goiftrue(G.fs,w)return w.f end;function c:breakstat(G)local ar=G.fs;local bv=ar.bl;local bP=false;while bv and not bv.isbreakable do if bv.upval then bP=true end;bv=bv.previous end;if not bv then d:syntaxerror(G,"no loop to break")end;if bP then g:codeABC(ar,"OP_CLOSE",bv.nactvar,0,0)end;bv.breaklist=g:concat(ar,bv.breaklist,g:jump(ar))end;function c:whilestat(G,bg)local ar=G.fs;local bv={}d:next(G)local bQ=g:getlabel(ar)local bR=self:cond(G)self:enterblock(ar,bv,true)self:checknext(G,"TK_DO")self:block(G)g:patchlist(ar,g:jump(ar),bQ)self:check_match(G,"TK_END","TK_WHILE",bg)self:leaveblock(ar)g:patchtohere(ar,bR)end;function c:repeatstat(G,bg)local ar=G.fs;local bS=g:getlabel(ar)local bT,bU={},{}self:enterblock(ar,bT,true)self:enterblock(ar,bU,false)d:next(G)self:chunk(G)self:check_match(G,"TK_UNTIL","TK_REPEAT",bg)local bR=self:cond(G)if not bU.upval then self:leaveblock(ar)g:patchlist(G.fs,bR,bS)else self:breakstat(G)g:patchtohere(G.fs,bR)self:leaveblock(ar)g:patchlist(G.fs,g:jump(ar),bS)end;self:leaveblock(ar)end;function c:exp1(G)local as={}self:expr(G,as)local aT=as.k;g:exp2nextreg(G.fs,as)return aT end;function c:forbody(G,bh,bg,br,bV)local bv={}local ar=G.fs;self:adjustlocalvars(G,3)self:checknext(G,"TK_DO")local bW=bV and g:codeAsBx(ar,"OP_FORPREP",bh,g.NO_JUMP)or g:jump(ar)self:enterblock(ar,bv,false)self:adjustlocalvars(G,br)g:reserveregs(ar,br)self:block(G)self:leaveblock(ar)g:patchtohere(ar,bW)local bX=bV and g:codeAsBx(ar,"OP_FORLOOP",bh,g.NO_JUMP)or g:codeABC(ar,"OP_TFORLOOP",bh,0,br)g:fixline(ar,bg)g:patchlist(ar,bV and bX or g:jump(ar),bW+1)end;function c:fornum(G,bp,bg)local ar=G.fs;local bh=ar.freereg;self:new_localvarliteral(G,"(for index)",0)self:new_localvarliteral(G,"(for limit)",1)self:new_localvarliteral(G,"(for step)",2)self:new_localvar(G,bp,3)self:checknext(G,'=')self:exp1(G)self:checknext(G,",")self:exp1(G)if self:testnext(G,",")then self:exp1(G)else g:codeABx(ar,"OP_LOADK",ar.freereg,g:numberK(ar,1))g:reserveregs(ar,1)end;self:forbody(G,bh,bg,1,true)end;function c:forlist(G,bY)local ar=G.fs;local as={}local br=0;local bh=ar.freereg;self:new_localvarliteral(G,"(for generator)",br)br=br+1;self:new_localvarliteral(G,"(for state)",br)br=br+1;self:new_localvarliteral(G,"(for control)",br)br=br+1;self:new_localvar(G,bY,br)br=br+1;while self:testnext(G,",")do self:new_localvar(G,self:str_checkname(G),br)br=br+1 end;self:checknext(G,"TK_IN")local bg=G.linenumber;self:adjust_assign(G,3,self:explist1(G,as),as)g:checkstack(ar,3)self:forbody(G,bh,bg,br-3,false)end;function c:forstat(G,bg)local ar=G.fs;local bv={}self:enterblock(ar,bv,true)d:next(G)local bp=self:str_checkname(G)local N=G.t.token;if N=="="then self:fornum(G,bp,bg)elseif N==","or N=="TK_IN"then self:forlist(G,bp)else d:syntaxerror(G,self:LUA_QL("=").." or "..self:LUA_QL("in").." expected")end;self:check_match(G,"TK_END","TK_FOR",bg)self:leaveblock(ar)end;function c:test_then_block(G)d:next(G)local bR=self:cond(G)self:checknext(G,"TK_THEN")self:block(G)return bR end;function c:ifstat(G,bg)local ar=G.fs;local bZ=g.NO_JUMP;local b_=self:test_then_block(G)while G.t.token=="TK_ELSEIF"do bZ=g:concat(ar,bZ,g:jump(ar))g:patchtohere(ar,b_)b_=self:test_then_block(G)end;if G.t.token=="TK_ELSE"then bZ=g:concat(ar,bZ,g:jump(ar))g:patchtohere(ar,b_)d:next(G)self:block(G)else bZ=g:concat(ar,bZ,b_)end;g:patchtohere(ar,bZ)self:check_match(G,"TK_END","TK_IF",bg)end;function c:localfunc(G)local w,l={},{}local ar=G.fs;self:new_localvar(G,self:str_checkname(G),0)self:init_exp(w,"VLOCAL",ar.freereg)g:reserveregs(ar,1)self:adjustlocalvars(G,1)self:body(G,l,false,G.linenumber)g:storevar(ar,w,l)self:getlocvar(ar,ar.nactvar-1).startpc=ar.pc end;function c:localstat(G)local br=0;local bw;local as={}repeat self:new_localvar(G,self:str_checkname(G),br)br=br+1 until not self:testnext(G,",")if self:testnext(G,"=")then bw=self:explist1(G,as)else as.k="VVOID"bw=0 end;self:adjust_assign(G,br,bw,as)self:adjustlocalvars(G,br)end;function c:funcname(G,w)local bF=false;self:singlevar(G,w)while G.t.token=="."do self:field(G,w)end;if G.t.token==":"then bF=true;self:field(G,w)end;return bF end;function c:funcstat(G,bg)local w,l={},{}d:next(G)local bF=self:funcname(G,w)self:body(G,l,bF,bg)g:storevar(G.fs,w,l)g:fixline(G.fs,bg)end;function c:exprstat(G)local ar=G.fs;local w={}w.v={}self:primaryexp(G,w.v)if w.v.k=="VCALL"then e:SETARG_C(g:getcode(ar,w.v),1)else w.prev=nil;self:assignment(G,w,1)end end;function c:retstat(G)local ar=G.fs;local as={}local D,aA;d:next(G)if self:block_follow(G.t.token)or G.t.token==";"then D,aA=0,0 else aA=self:explist1(G,as)if self:hasmultret(as.k)then g:setmultret(ar,as)if as.k=="VCALL"and aA==1 then e:SET_OPCODE(g:getcode(ar,as),"OP_TAILCALL")i(e:GETARG_A(g:getcode(ar,as))==ar.nactvar)end;D=ar.nactvar;aA=self.LUA_MULTRET else if aA==1 then D=g:exp2anyreg(ar,as)else g:exp2nextreg(ar,as)D=ar.nactvar;i(aA==ar.freereg-D)end end end;g:ret(ar,D,aA)end;function c:statement(G)local bg=G.linenumber;local N=G.t.token;if N=="TK_IF"then self:ifstat(G,bg)return false elseif N=="TK_WHILE"then self:whilestat(G,bg)return false elseif N=="TK_DO"then d:next(G)self:block(G)self:check_match(G,"TK_END","TK_DO",bg)return false elseif N=="TK_FOR"then self:forstat(G,bg)return false elseif N=="TK_REPEAT"then self:repeatstat(G,bg)return false elseif N=="TK_FUNCTION"then self:funcstat(G,bg)return false elseif N=="TK_LOCAL"then d:next(G)if self:testnext(G,"TK_FUNCTION")then self:localfunc(G)else self:localstat(G)end;return false elseif N=="TK_RETURN"then self:retstat(G)return true elseif N=="TK_BREAK"then d:next(G)self:breakstat(G)return true else self:exprstat(G)return false end end;function c:chunk(G)local c0=false;self:enterlevel(G)while not c0 and not self:block_follow(G.t.token)do c0=self:statement(G)self:testnext(G,";")i(G.fs.f.maxstacksize>=G.fs.freereg and G.fs.freereg>=G.fs.nactvar)G.fs.freereg=G.fs.nactvar end;self:leavelevel(G)end;d:init()local c1={}a=function(n,name)name=name or'compiled-lua'local c2=b:init(b:make_getF(n),nil)if not c2 then return end;local b4=c:parser(c1,c2,nil,"@"..name)local ae,k=f:make_setS()f:dump(c1,b4,ae,k)return k.data end end;local c3;do local bit=bit or bit32 or require('bit')if not table.create then function table.create(y)return{}end end;if not table.unpack then table.unpack=unpack end;if not table.pack then function table.pack(...)return{n=select('#',...),...}end end;if not table.move then function table.move(c4,D,c5,aG,c6)for Y=0,c5-D do c6[aG+Y]=c4[D+Y]end end end;local c7;local c8;local c9;local ca=50;local cb={[22]=18,[31]=8,[33]=28,[0]=3,[1]=13,[2]=23,[26]=33,[12]=1,[13]=6,[14]=10,[15]=16,[16]=20,[17]=26,[18]=30,[19]=36,[3]=0,[4]=2,[5]=4,[6]=7,[7]=9,[8]=12,[9]=14,[10]=17,[20]=19,[21]=22,[23]=24,[24]=27,[25]=29,[27]=32,[32]=34,[34]=37,[11]=5,[28]=11,[29]=15,[30]=21,[35]=25,[36]=31,[37]=35}local cc={[0]='ABC','ABx','ABC','ABC','ABC','ABx','ABC','ABx','ABC','ABC','ABC','ABC','ABC','ABC','ABC','ABC','ABC','ABC','ABC','ABC','ABC','ABC','AsBx','ABC','ABC','ABC','ABC','ABC','ABC','ABC','ABC','AsBx','AsBx','ABC','ABC','ABC','ABx','ABC'}local cd={[0]={b='OpArgR',c='OpArgN'},{b='OpArgK',c='OpArgN'},{b='OpArgU',c='OpArgU'},{b='OpArgR',c='OpArgN'},{b='OpArgU',c='OpArgN'},{b='OpArgK',c='OpArgN'},{b='OpArgR',c='OpArgK'},{b='OpArgK',c='OpArgN'},{b='OpArgU',c='OpArgN'},{b='OpArgK',c='OpArgK'},{b='OpArgU',c='OpArgU'},{b='OpArgR',c='OpArgK'},{b='OpArgK',c='OpArgK'},{b='OpArgK',c='OpArgK'},{b='OpArgK',c='OpArgK'},{b='OpArgK',c='OpArgK'},{b='OpArgK',c='OpArgK'},{b='OpArgK',c='OpArgK'},{b='OpArgR',c='OpArgN'},{b='OpArgR',c='OpArgN'},{b='OpArgR',c='OpArgN'},{b='OpArgR',c='OpArgR'},{b='OpArgR',c='OpArgN'},{b='OpArgK',c='OpArgK'},{b='OpArgK',c='OpArgK'},{b='OpArgK',c='OpArgK'},{b='OpArgR',c='OpArgU'},{b='OpArgR',c='OpArgU'},{b='OpArgU',c='OpArgU'},{b='OpArgU',c='OpArgU'},{b='OpArgU',c='OpArgN'},{b='OpArgR',c='OpArgN'},{b='OpArgR',c='OpArgN'},{b='OpArgN',c='OpArgU'},{b='OpArgU',c='OpArgU'},{b='OpArgN',c='OpArgN'},{b='OpArgU',c='OpArgN'},{b='OpArgU',c='OpArgN'}}local function ce(c4,O,as,cf)local cg=0;for Y=O,as,cf do local ch=256^math.abs(Y-O)cg=cg+ch*string.byte(c4,Y,Y)end;return cg end;local function ci(cj,ck,cl,cm)local ai=(-1)^bit.rshift(cm,7)local cn=bit.rshift(cl,7)+bit.lshift(bit.band(cm,0x7F),1)local co=cj+bit.lshift(ck,8)+bit.lshift(bit.band(cl,0x7F),16)local cp=1;if cn==0 then if co==0 then return ai*0 else cp=0;cn=1 end elseif cn==0x7F then if co==0 then return ai*1/0 else return ai*0/0 end end;return ai*2^(cn-127)*(1+cp/2^23)end;local function cq(cj,ck,cl,cm,cr,cs,ct,cu)local ai=(-1)^bit.rshift(cu,7)local cn=bit.lshift(bit.band(cu,0x7F),4)+bit.rshift(ct,4)local co=bit.band(ct,0x0F)*2^48;local cp=1;co=co+cs*2^40+cr*2^32+cm*2^24+cl*2^16+ck*2^8+cj;if cn==0 then if co==0 then return ai*0 else cp=0;cn=1 end elseif cn==0x7FF then if co==0 then return ai*1/0 else return ai*0/0 end end;return ai*2^(cn-1023)*(cp+co/2^52)end;local function cv(c4,O,as)return ce(c4,O,as-1,1)end;local function cw(c4,O,as)return ce(c4,as-1,O,-1)end;local function cx(c4,O)return ci(string.byte(c4,O,O+3))end;local function cy(c4,O)local cj,ck,cl,cm=string.byte(c4,O,O+3)return ci(cm,cl,ck,cj)end;local function cz(c4,O)return cq(string.byte(c4,O,O+7))end;local function cA(c4,O)local cj,ck,cl,cm,cr,cs,ct,cu=string.byte(c4,O,O+7)return cq(cu,ct,cs,cr,cm,cl,ck,cj)end;local cB={[4]={little=cx,big=cy},[8]={little=cz,big=cA}}local function cC(cD)local aU=cD.index;local cE=string.byte(cD.source,aU,aU)cD.index=aU+1;return cE end;local function cF(cD,F)local p=cD.index+F;local A=string.sub(cD.source,cD.index,p-1)cD.index=p;return A end;local function cG(cD)local F=cD:s_szt()local A;if F~=0 then A=string.sub(cF(cD,F),1,-2)end;return A end;local function cH(F,b4)return function(cD)local p=cD.index+F;local cI=b4(cD.source,cD.index,p)cD.index=p;return cI end end;local function cJ(F,b4)return function(cD)local cK=b4(cD.source,cD.index)cD.index=cD.index+F;return cK end end;local function cL(cD)local F=cD:s_int()local aJ=table.create(F)for Y=1,F do local cM=cD:s_ins()local a9=bit.band(cM,0x3F)local bH=cc[a9]local cN=cd[a9]local m={value=cM,op=cb[a9],A=bit.band(bit.rshift(cM,6),0xFF)}if bH=='ABC'then m.B=bit.band(bit.rshift(cM,23),0x1FF)m.C=bit.band(bit.rshift(cM,14),0x1FF)m.is_KB=cN.b=='OpArgK'and m.B>0xFF;m.is_KC=cN.c=='OpArgK'and m.C>0xFF elseif bH=='ABx'then m.Bx=bit.band(bit.rshift(cM,14),0x3FFFF)m.is_K=cN.b=='OpArgK'elseif bH=='AsBx'then m.sBx=bit.band(bit.rshift(cM,14),0x3FFFF)-131071 end;aJ[Y]=m end;return aJ end;local function cO(cD)local F=cD:s_int()local aJ=table.create(F)for Y=1,F do local ag=cC(cD)local aT;if ag==1 then aT=cC(cD)~=0 elseif ag==3 then aT=cD:s_num()elseif ag==4 then aT=cG(cD)end;aJ[Y]=aT end;return aJ end;local function cP(cD,c4)local F=cD:s_int()local aJ=table.create(F)for Y=1,F do aJ[Y]=c9(cD,c4)end;return aJ end;local function cQ(cD)local F=cD:s_int()local aJ=table.create(F)for Y=1,F do aJ[Y]=cD:s_int()end;return aJ end;local function cR(cD)local F=cD:s_int()local aJ=table.create(F)for Y=1,F do aJ[Y]={varname=cG(cD),startpc=cD:s_int(),endpc=cD:s_int()}end;return aJ end;local function cS(cD)local F=cD:s_int()local aJ=table.create(F)for Y=1,F do aJ[Y]=cG(cD)end;return aJ end;function c9(cD,cT)local cU={}local c4=cG(cD)or cT;cU.source=c4;cD:s_int()cD:s_int()cU.num_upval=cC(cD)cU.num_param=cC(cD)cC(cD)cU.max_stack=cC(cD)cU.code=cL(cD)cU.const=cO(cD)cU.subs=cP(cD,c4)cU.lines=cQ(cD)cR(cD)cS(cD)for y,w in ipairs(cU.code)do if w.is_K then w.const=cU.const[w.Bx+1]else if w.is_KB then w.const_B=cU.const[w.B-0xFF]end;if w.is_KC then w.const_C=cU.const[w.C-0xFF]end end end;return cU end;function c7(c4)local cV;local cW;local cX;local cY;local cZ;local c_;local d0;local d1={index=1,source=c4}assert(cF(d1,4)=='\27Lua','invalid Lua signature')assert(cC(d1)==0x51,'invalid Lua version')assert(cC(d1)==0,'invalid Lua format')cW=cC(d1)~=0;cX=cC(d1)cY=cC(d1)cZ=cC(d1)c_=cC(d1)d0=cC(d1)~=0;cV=cW and cv or cw;d1.s_int=cH(cX,cV)d1.s_szt=cH(cY,cV)d1.s_ins=cH(cZ,cV)if d0 then d1.s_num=cH(c_,cV)elseif cB[c_]then d1.s_num=cJ(c_,cB[c_][cW and'little'or'big'])else error('unsupported float size')end;return c9(d1,'@virtual')end;local function d2(aJ,d3)for Y,d4 in pairs(aJ)do if d4.index>=d3 then d4.value=d4.store[d4.index]d4.store=d4;d4.index='value'aJ[Y]=nil end end end;local function d5(aJ,d3,d6)local d7=aJ[d3]if not d7 then d7={index=d3,store=d6}aJ[d3]=d7 end;return d7 end;local function d8(d9,da)local c4=d9.source;local bg=d9.lines[d9.pc-1]error(string.format('%s:%i: %s',c4,bg,da),0)end;local function db(dc,dd,de)local df=dc.code;local dg=dc.subs;local dh=dc.vararg;local di=-1;local dj={}local d6=dc.memory;local aD=dc.pc;while true do local dk=df[aD]local a9=dk.op;aD=aD+1;if a9<18 then if a9<8 then if a9<3 then if a9<1 then for Y=dk.A,dk.B do d6[Y]=nil end elseif a9>1 then local d4=de[dk.B]d6[dk.A]=d4.store[d4.index]else local dl,dm;if dk.is_KB then dl=dk.const_B else dl=d6[dk.B]end;if dk.is_KC then dm=dk.const_C else dm=d6[dk.C]end;d6[dk.A]=dl+dm end elseif a9>3 then if a9<6 then if a9>4 then local at=dk.A;local aB=dk.B;local d3;if dk.is_KC then d3=dk.const_C else d3=d6[dk.C]end;d6[at+1]=d6[aB]d6[at]=d6[aB][d3]else d6[dk.A]=dd[dk.const]end elseif a9>6 then local d3;if dk.is_KC then d3=dk.const_C else d3=d6[dk.C]end;d6[dk.A]=d6[dk.B][d3]else local dl,dm;if dk.is_KB then dl=dk.const_B else dl=d6[dk.B]end;if dk.is_KC then dm=dk.const_C else dm=d6[dk.C]end;d6[dk.A]=dl-dm end else d6[dk.A]=d6[dk.B]end elseif a9>8 then if a9<13 then if a9<10 then dd[dk.const]=d6[dk.A]elseif a9>10 then if a9<12 then local at=dk.A;local aB=dk.B;local aC=dk.C;local dn;if aB==0 then dn=di-at else dn=aB-1 end;local dp=table.pack(d6[at](table.unpack(d6,at+1,at+dn)))local dq=dp.n;if aC==0 then di=at+dq-1 else dq=aC-1 end;table.move(dp,1,dq,at,d6)else local d4=de[dk.B]d4.store[d4.index]=d6[dk.A]end else local dl,dm;if dk.is_KB then dl=dk.const_B else dl=d6[dk.B]end;if dk.is_KC then dm=dk.const_C else dm=d6[dk.C]end;d6[dk.A]=dl*dm end elseif a9>13 then if a9<16 then if a9>14 then local at=dk.A;local aB=dk.B;local dn;if aB==0 then dn=di-at else dn=aB-1 end;d2(dj,0)return d6[at](table.unpack(d6,at+1,at+dn))else local d3,dr;if dk.is_KB then d3=dk.const_B else d3=d6[dk.B]end;if dk.is_KC then dr=dk.const_C else dr=d6[dk.C]end;d6[dk.A][d3]=dr end elseif a9>16 then d6[dk.A]={}else local dl,dm;if dk.is_KB then dl=dk.const_B else dl=d6[dk.B]end;if dk.is_KC then dm=dk.const_C else dm=d6[dk.C]end;d6[dk.A]=dl/dm end else d6[dk.A]=dk.const end else local at=dk.A;local ds=d6[at+2]local d3=d6[at]+ds;local bl=d6[at+1]local dt;if ds==math.abs(ds)then dt=d3<=bl else dt=d3>=bl end;if dt then d6[at]=d3;d6[at+3]=d3;aD=aD+dk.sBx end end elseif a9>18 then if a9<28 then if a9<23 then if a9<20 then d6[dk.A]=#d6[dk.B]elseif a9>20 then if a9<22 then local at=dk.A;local aB=dk.B;local F;if aB==0 then F=di-at+1 else F=aB-1 end;d2(dj,0)return table.unpack(d6,at,at+F-1)else local aB=dk.B;local A=d6[aB]for Y=aB+1,dk.C do A=A..d6[Y]end;d6[dk.A]=A end else local dl,dm;if dk.is_KB then dl=dk.const_B else dl=d6[dk.B]end;if dk.is_KC then dm=dk.const_C else dm=d6[dk.C]end;d6[dk.A]=dl%dm end elseif a9>23 then if a9<26 then if a9>24 then d2(dj,dk.A)else local dl,dm;if dk.is_KB then dl=dk.const_B else dl=d6[dk.B]end;if dk.is_KC then dm=dk.const_C else dm=d6[dk.C]end;if dl==dm==(dk.A~=0)then aD=aD+df[aD].sBx end;aD=aD+1 end elseif a9>26 then local dl,dm;if dk.is_KB then dl=dk.const_B else dl=d6[dk.B]end;if dk.is_KC then dm=dk.const_C else dm=d6[dk.C]end;if dl<dm==(dk.A~=0)then aD=aD+df[aD].sBx end;aD=aD+1 else local dl,dm;if dk.is_KB then dl=dk.const_B else dl=d6[dk.B]end;if dk.is_KC then dm=dk.const_C else dm=d6[dk.C]end;d6[dk.A]=dl^dm end else d6[dk.A]=dk.B~=0;if dk.C~=0 then aD=aD+1 end end elseif a9>28 then if a9<33 then if a9<30 then local dl,dm;if dk.is_KB then dl=dk.const_B else dl=d6[dk.B]end;if dk.is_KC then dm=dk.const_C else dm=d6[dk.C]end;if dl<=dm==(dk.A~=0)then aD=aD+df[aD].sBx end;aD=aD+1 elseif a9>30 then if a9<32 then local du=dg[dk.Bx+1]local bt=du.num_upval;local dv;if bt~=0 then dv={}for Y=1,bt do local dw=df[aD+Y-1]if dw.op==cb[0]then dv[Y-1]=d5(dj,dw.B,d6)elseif dw.op==cb[4]then dv[Y-1]=de[dw.B]end end;aD=aD+bt end;d6[dk.A]=c8(du,dd,dv)else local at=dk.A;local aB=dk.B;if not d6[aB]~=(dk.C~=0)then d6[at]=d6[aB]aD=aD+df[aD].sBx end;aD=aD+1 end else d6[dk.A]=-d6[dk.B]end elseif a9>33 then if a9<36 then if a9>34 then local at=dk.A;local F=dk.B;if F==0 then F=dh.len;di=at+F-1 end;table.move(dh.list,1,F,at,d6)else local at=dk.A;local dx,bl,ds;dx=assert(tonumber(d6[at]),'`for` initial value must be a number')bl=assert(tonumber(d6[at+1]),'`for` limit must be a number')ds=assert(tonumber(d6[at+2]),'`for` step must be a number')d6[at]=dx-ds;d6[at+1]=bl;d6[at+2]=ds;aD=aD+dk.sBx end elseif a9>36 then local at=dk.A;local aC=dk.C;local F=dk.B;local dy=d6[at]local aG;if F==0 then F=di-at end;if aC==0 then aC=dk[aD].value;aD=aD+1 end;aG=(aC-1)*ca;table.move(d6,at+1,at+F,aG+1,dy)else d6[dk.A]=not d6[dk.B]end else if not d6[dk.A]~=(dk.C~=0)then aD=aD+df[aD].sBx end;aD=aD+1 end else local at=dk.A;local bh=at+3;local dz={d6[at](d6[at+1],d6[at+2])}table.move(dz,1,dk.C,bh,d6)if d6[bh]~=nil then d6[at+2]=d6[bh]aD=aD+df[aD].sBx end;aD=aD+1 end else aD=aD+dk.sBx end;dc.pc=aD end end;function c8(cU,dd,bP)local function dA(...)local dB=table.pack(...)local d6=table.create(cU.max_stack)local dh={len=0,list={}}table.move(dB,1,cU.num_param,0,d6)if cU.num_param<dB.n then local dC=cU.num_param+1;local F=dB.n-cU.num_param;dh.len=F;table.move(dB,dC,dC+F-1,1,dh.list)end;local dc={vararg=dh,memory=d6,code=cU.code,subs=cU.subs,pc=1}local P=table.pack(pcall(db,dc,dd,bP))if P[1]then return table.unpack(P,2,P.n)else local d9={pc=dc.pc,source=cU.source,lines=cU.lines}d8(d9,P[2])return end end;return dA end;c3=function(dD,dd)return c8(c7(dD),dd or getfenv(0))end end;getfenv().script=nil;return function(n,dd)local dE;local dd=dd or getfenv(2)local name=dd.script and dd.script:GetFullName()local dF,dG=pcall(function()local dH=a(n,name)dE=c3(dH,dd)end)if dF then return setfenv(dE,dd)end;return nil,dG end
